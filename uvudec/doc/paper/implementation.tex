\section{Implementation}
\label{sec::implementation}
We have three primary subsystems in our implementation of the DES birthday
attack.  Each system was developed in isolation from the others in order to
facilitate thorough benchmarking within the bounds ofthe resource usage limits
imposed upon us.  We cover the transport subsystem and the storage subsystme in
this paper (sections \ref{sec::implementation::transport} and
\ref{sec::implementation::storage} respectively); we do not discuss our
implementation of DES as it is, in large part, a modified version of the
implementation found in the Gnu Privacy Guard software suite.

\subsection{Transport Subsystem (MPI)}
\label{sec::implementation::transport}
% Written by Rob
The transport subsystem is responsible for generating permutations of messages,
and passing it between the subsystems as appropriate.  It is implemented on top
of MPI so that it may easily work in many parallel environments.

The transport system is responsible for generating messages presented to the
user for signing, and forged messages.  For DES, this implies $2^{32}$ messages.
On a machine with $N$ processor, each processor is responsible for generating
$\frac{2^{32}}{N}$ messages of each type.  The easiest method for generating
$2^{32}$ different combinations of a message is to have thirty two points where
a message can be changed without altering its meaning.  Each message can then be
uniquely referenced by an unsigned 32-bit integer without any loss of
information.

Each message is hashed using the desired hashing scheme (in our case DES).  The
message's permutation number (the 32-bit integer that identifies the message)
and the hash of the message are both sent to a host determined by the 64-bit
hash modulo the number of MPI tasks.

In this scheme each MPI task is responsible for an equal share of message
generation.  If the hashing algorithm generates a uniform distribution of hash
values, then each MPI task is also responsible for an equal share of collision
checking.  Designers of hashing functions find it desirable to have a uniform
distribution of hashes even for inputs that share much data; as such, it is a
safe assumption to say that each MPI task will be responsible for an equal share
of collision checking.

The storage subsystem described in \ref{sec::implementation::storage} provides
an in-depth description of how collisions are detected within any given MPI
task.

As mentioned in section \ref{sec::implementation}, compromises were made in
order to achieve a solution that fits within the resource usage limits provided
to us.  First and foremost, our implementation skips generating messages
themselves and instead hashes the permutation number of the message.  Another
consequence of resource limits is the hashing implementation in the birthday
attack program is simple and does not have the overhead of DES.  A comparison of
the implementations may be found in sections \ref{sec::performance::mock} and 
\ref{sec::performance::des}.

Further issues encountered with the implementation will be described in section
\ref{sec::performance::transport} as they have more implications for performance
than for feature-completeness.

\subsection{Storage Subsystem (IO)}
\label{sec::implementation::storage}
The hash collision model tracks all generated hashes. It strives to be efficient,
very quick, and robust. In performing a birthday attack the full $2^{64}$ range of
possible hashes need not be explored. Instead,  only $2 \times 2^{32}$hashes need
to be stored. The first $2^{32}$ keeps track of the benignly modified document.
The second $2^{32}$ set of hashes keeps track of the maliciously modified document.

In our design each node contains a storage model. The model abstracts away the details, taking
in a 64-bit hash, 64-bit permutation ID, and a node ID. It returns 1 if a collision is detected,
otherwise 0 to indicate that the has was successfully inserted into the model. 

Underneath, storage is implemented using a very large tree structure. This is ideal for randomized inputs,
which will grow the tree in a balanced manner. Each model maps one file to memory using the POSIX mmap 
system call. The advantage is that the operating system takes care of caching and swapping memory from disk 
to memory behind the scenes. After an initial penalty for loading the file reads and writes are nearly as fast
as purely working with memory. Since each file is read and modified by only one process file operations can be
masked by the operating system. The downside is a large number of nodes are then required to
store all of the hashes. For our system $2^{33}$ hashes at 24 bytes per hash requires 192GB total data.
With 128 nodes this is 1.5GB per node.


