/*
UVNet Universal Decompiler (uvudec)
Copyright 2008 John McMaster
JohnDMcMaster@gmail.com
Licensed under terms of the three clause BSD license, see LICENSE for details
*/


#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <assert.h>
#include <sys/stat.h>
#include <vector>
#include <algorithm>
#include "uvd_ascii_art.h"
#include "uvd_debug.h"
#include "uvd_error.h"
#include "uvd_log.h"
#include "uvd_util.h"
#include "uvd.h"
#include "uvd_address.h"
#include "uvd_analysis.h"
#include "uvd_benchmark.h"
#include "uvd_data.h"
#include "uvd_format.h"
#include "uvd_instruction.h"
#include "uvd_types.h"
#include "uvd_config_symbol.h"

/*
UVDIterator::UVDIterator()
{
	m_uvd = NULL;
}
*/

UVDIterator::UVDIterator(UVD *disassembler)
{
	if( g_config )
	{
		UV_DEBUG(init(disassembler, g_config->m_addr_min, 0));
	}
}

UVDIterator::UVDIterator(UVD *disassembler, unsigned int position, unsigned int index)
{
	UV_DEBUG(init(disassembler, position, index));
}

UVDIterator::~UVDIterator()
{
	UV_DEBUG(deinit());
}

uv_err_t UVDIterator::init(UVD *disassembler, unsigned int position, unsigned int index)
{
	//UV_ENTER();
	m_uvd = disassembler;
	m_nextPosition = position;
	m_positionIndex = index;
	m_printedInformation = false;
	return UV_ERR_OK;
}

uv_err_t UVDIterator::deinit()
{
	m_data = NULL;
	m_uvd = NULL;
	return UV_ERR_OK;
}

unsigned int UVDIterator::getPosition()
{
	return m_nextPosition;
}

UVDIterator UVDIterator::operator++()
{
	next();
	return *this;
}

uv_err_t UVDIterator::next()
{
	uv_err_t rc = UV_ERR_GENERAL;
	UVDBenchmark nextInstructionBenchmark;
	
	UV_ENTER();
		
	uv_assert_ret(g_config);
	
	if( *this == m_uvd->end() )
	{
		return UV_DEBUG(UV_ERR_GENERAL);
	}
		
	++m_positionIndex;

	printf_debug("next(), position index: %d, index buffer size: %d\n", m_positionIndex, m_indexBuffer.size());
	printf_debug("m_nextPosition: 0x%.8X\n", m_nextPosition);
	
	//We may have buffered data leftover form last parse
	//Check this before seeing if we are at end
	//Take buffered element if availible
	if( m_positionIndex < m_indexBuffer.size() )
	{
		rc = UV_ERR_OK;
		goto error;
	}
	
	//Global debug sort of cutoff
	//Force to end
	if( m_nextPosition > g_config->m_addr_max )
	{
		*this = m_uvd->end();
		return UV_ERR_DONE;
	}

	//Otherwise, get next output cluster
	
	//Advance to next position
	uv_assert_err_ret(nextCore());
	rc = UV_ERR_OK;
error:
	nextInstructionBenchmark.stop();
	//printf_debug_level(UVD_DEBUG_PASSES, "next() time: %s\n", nextInstructionBenchmark.toString().c_str());
	return rc;
}

/*
Make it print nicely for output
Any non-printable characters should be converted to some "nicer" form
*/
std::string stringTableStringFormat(const std::string &s)
{
	std::string sRet;
	
	for( std::string::size_type i = 0; i < s.size(); ++i )
	{
		char c = s[i];
		
		if( isprint(c) )
		{
			sRet += c;
		}
		else
		{
			char buff[64];
		
			//<0x0A> form
			snprintf(buff, 64, "<0x%.2X>", (unsigned int)(unsigned char)c);
			sRet += buff;
		}
	}
	return sRet;
}

uv_err_t UVDIterator::printReferenceList(UVDAnalyzedMemoryLocation *memLoc, uint32_t type)
{
	UVDAnalyzedMemoryLocationReferences references;
	char buff[256];
	UVD *uvd = NULL;
	UVDFormat *format = NULL;
		
	uvd = m_uvd;
	uv_assert_ret(uvd);
	format = uvd->m_format;
	uv_assert_ret(format);

	//Get all the locations that call this address
	//FIXME: should this be call source?
	uv_assert_err_ret(memLoc->getReferences(references, type));

	for( UVDAnalyzedMemoryLocationReferences::iterator iter = references.begin(); iter != references.end(); ++iter )
	{
		//uint32_t key = (*iter).first;
		UVDMemoryReference *value = (*iter).second;
		uint32_t from = 0;
		
		uv_assert_err_ret(value);
		from = value->m_from;
		
		snprintf(buff, 256, "#\t%s", format->formatAddress(from).c_str());
		m_indexBuffer.push_back(buff);
	}
	
	return UV_ERR_OK;
}

uv_err_t UVDIterator::initialPrint()
{
	UVDConfig *config = NULL;
	UVDAnalyzer *analyzer = NULL;
	char szBuff[256];
	
	UV_ENTER();
	
	uv_assert_ret(m_uvd);
	config = m_uvd->m_config;
	uv_assert_ret(config);

	uv_assert_ret(m_uvd);
	analyzer = m_uvd->m_analyzer;
	
	if( config->m_print_header )
	{
		std::string line;
		
		//Program info
		snprintf(szBuff, 256, "Generated by uvudec version %s", UVUDEC_VER_STRING);
		uv_assert_err_ret(m_uvd->m_format->m_compiler->comment(szBuff, line));
		m_indexBuffer.push_back(line);
		snprintf(szBuff, 256, "uvudec copyright 2009 John McMaster");
		m_indexBuffer.push_back(line);
		snprintf(szBuff, 256, "JohnDMcMaster@gmail.com");
		m_indexBuffer.push_back(line);
		m_indexBuffer.push_back("");
		m_indexBuffer.push_back("");
	}
	
	if( config->m_uselessASCIIArt )
	{
		std::string art = getRandomUVNetASCIIArt() + "\n";
		m_indexBuffer.push_back(art);
		m_indexBuffer.push_back("");
		m_indexBuffer.push_back("");		
	}

	//String table
	if( config->m_print_string_table )
	{
		snprintf(szBuff, 256, "# String table:");
		m_indexBuffer.push_back(szBuff);

		uv_assert_ret(m_data);

		for( UVDAnalyzedMemorySpace::iterator iter = analyzer->m_stringAddresses.begin(); iter != analyzer->m_stringAddresses.end(); ++iter )
		{
			UVDAnalyzedMemoryLocation *mem = (*iter).second;
			std::string sData;
			std::vector<std::string> lines;
			
			//Read a string
			m_data->read(mem->m_min_addr, sData, mem->m_max_addr - mem->m_min_addr);
	
			
			lines = split(sData, '\n', true);
			
			if( lines.size() == 1 )
			{
				snprintf(szBuff, 256, "# 0x%.8X: %s", mem->m_min_addr, stringTableStringFormat(lines[0]).c_str());
				m_indexBuffer.push_back(szBuff);				
			}
			else
			{
				snprintf(szBuff, 256, "# 0x%.8X:", mem->m_min_addr);
				m_indexBuffer.push_back(szBuff);				
				for( std::vector<std::string>::size_type i = 0; i < lines.size(); ++i )
				{
					snprintf(szBuff, 256, "#\t%s", stringTableStringFormat(lines[i]).c_str());
					m_indexBuffer.push_back(szBuff);				
				}
			}
		}
		m_indexBuffer.push_back("");
		m_indexBuffer.push_back("");
	}

	m_printedInformation = true;
	return UV_ERR_OK;
}

/*
Gets the next logical print group
These all should be associated with a small peice of data, such as a single instruction
Ex: an address on line above + call count + disassembled instruction
*/
uv_err_t UVDIterator::nextCore()
{
	uv_err_t rc = UV_ERR_GENERAL;
	UVDInstruction instruction;
	unsigned int startPosition = m_nextPosition;
	UVD *uvd = NULL;
	UVDAnalyzer *analyzer = NULL;
	UVDFormat *format = NULL;
	UVDAnalyzedMemorySpace calledAddresses;
	UVDAnalyzedMemorySpace jumpedAddresses;
	UVDBenchmark nextInstructionBenchmark;
	UVDBenchmark otherBenchmark;
	
	UV_ENTER();
	
	uvd = m_uvd;
	uv_assert_ret(uvd);
	analyzer = uvd->m_analyzer;
	uv_assert_ret(analyzer);
	format = uvd->m_format;
	uv_assert_ret(format);

	uv_assert_ret(g_config);
	
	UV_ENTER();
	m_indexBuffer.clear();
	printf_debug("m_nextPosition: 0x%.8X\n", m_nextPosition);

	if( !m_printedInformation )
	{
		uv_assert_err_ret(initialPrint());	
		//We may have had all prelim prints disabled
		if( !m_indexBuffer.empty() )
		{			
			rc = UV_ERR_OK;
			goto error;
		}
	}
		
	nextInstructionBenchmark.start();
	if( UV_FAILED(nextInstruction(instruction)) )
	{
		printf_debug("Failed to get next instruction\n");
		UV_ERR(rc);
		goto error;
	}	
	nextInstructionBenchmark.stop();
	//printf_debug_level(UVD_DEBUG_SUMMARY, "nextInstruction() time: %s\n", nextInstructionBenchmark.toString().c_str());
	
	otherBenchmark.start();
	
	if( g_config->m_addr_label )
	{
		char buff[256];
		
		//This is like convention adapted by ds52
		//Limit leading zeros by max address size?
		//X00001234:
		snprintf(buff, 256, "X%.8X:", startPosition);
		
		m_indexBuffer.insert(m_indexBuffer.end(), buff);
	}

	if( g_config->m_addr_comment )
	{
		char buff[256];
		
		//0x00001234:
		snprintf(buff, 256, "# 0x%.8X", startPosition);
		
		m_indexBuffer.insert(m_indexBuffer.end(), buff);
	}
	
	if( g_config->m_called_sources )
	{
		uv_assert_err_ret(analyzer->getCalledAddresses(calledAddresses));
		if( calledAddresses.find(startPosition) != calledAddresses.end() )
		{
			char buff[256];
			std::string sNameBlock;
			UVDAnalyzedFunction analyzedFunction;
			UVDAnalyzedFunctionShared *analyzedFunctionShared = NULL;
			UVDAnalyzedMemoryLocation *memLoc = (*(calledAddresses.find(startPosition))).second;
			
			uv_assert_err_ret(m_uvd->analyzeNewFunction(memLoc, analyzedFunction));

			analyzedFunctionShared = analyzedFunction.m_shared;
			//empty name indicates no data
			if( !analyzedFunctionShared->m_sName.empty() )
			{
				sNameBlock = analyzedFunctionShared->m_sName + "(args?) ";
			}
			
			m_indexBuffer.insert(m_indexBuffer.end(), "\n");
			m_indexBuffer.insert(m_indexBuffer.end(), "\n");
			snprintf(buff, 256, "# FUNCTION START %s@ %s", sNameBlock.c_str(), format->formatAddress(startPosition).c_str());
			m_indexBuffer.insert(m_indexBuffer.end(), buff);

			//Print number of callees?
			if( g_config->m_called_count )
			{
				snprintf(buff, 256, "# References: %d", memLoc->getReferenceCount());
				m_indexBuffer.push_back(buff);
			}

			//Print callees?
			if( g_config->m_called_sources )
			{
				uv_assert_err_ret(printReferenceList(memLoc, UVD_MEMORY_REFERENCE_CALL_DEST));
			}
		}
	}
	
	if( g_config->m_jumped_sources )
	{
		uv_assert_err_ret(analyzer->getJumpedAddresses(jumpedAddresses));
		//Can be an entry and continue point
		if( jumpedAddresses.find(startPosition) != jumpedAddresses.end() )
		{
			char buff[256];
			std::string sNameBlock;
			UVDAnalyzedFunction analyzedFunction;
			UVDAnalyzedMemoryLocation *memLoc = (*(jumpedAddresses.find(startPosition))).second;
					
			snprintf(buff, 256, "# Jump destination %s@ %s", sNameBlock.c_str(), format->formatAddress(startPosition).c_str());
			m_indexBuffer.push_back(buff);

			//Print number of references?
			if( g_config->m_jumped_count )
			{
				snprintf(buff, 256, "# References: %d", memLoc->getReferenceCount());
				m_indexBuffer.push_back(buff);
			}

			//Print sources?
			if( g_config->m_jumped_sources )
			{
				uv_assert_err_ret(printReferenceList(memLoc, UVD_MEMORY_REFERENCE_JUMP_DEST));
			}
		}
	}

	//Best to have data follow analysis
	//Instruction is fully parsed now
	//Convert to necessary string values
	if( UV_FAILED(m_uvd->stringListAppend(&instruction, m_indexBuffer)) )
	{
		UV_ERR(rc);
		goto error;
	}
	printf_debug("Generated string list, size: %d\n", m_indexBuffer.size());

	otherBenchmark.stop();
	//printf_debug_level(UVD_DEBUG_SUMMARY, "other than nextInstruction() time: %s\n", otherBenchmark.toString().c_str());

	rc = UV_ERR_OK;
	
error:
	return UV_DEBUG(rc);
}

/*
Gets the next logical print group
These all should be associated with a small peice of data, such as a single instruction
Ex: an address on line above + call count + disassembled instruction
*/
uv_err_t UVDIterator::nextInstruction(UVDInstruction &instructionIn)
{
/*
Ret holds a UVDInstruction ** that we should fill
UV_DISASM_FUNC_PROTO(uvd_next)
{
*/
	uv_err_t rc = UV_ERR_GENERAL;
	UVDInstructionShared *inst_shared = NULL;
	UVDInstruction *inst = &instructionIn;
	uint8_t opcode = 0;
	unsigned int position = 0;
	//UVDData *data = m_uvd->m_data;
	UVDData *data = m_data;
	UVDOpcodeLookupElement *element = NULL;
	int opcodeRead = 0;
	UVD *uvd = NULL;
	
	UV_ENTER();
	printf_debug("\n");
	printf_debug("m_nextPosition: 0x%.8X\n", m_nextPosition);
	
	uvd = m_uvd;
	uv_assert_ret(uvd);
	uv_assert(data);
	
	if( m_nextPosition > g_config->m_addr_max )
	{
		*this = m_uvd->end();
		return UV_ERR_DONE;
	}

	/*
	uv_assert(binary);
	uv_assert(offset);
	uv_assert(ret);
	*/
	
	//Make sure we are in a coding region
	//Number of non-coding addresses is expected to be small at this point
	//Better algorithm later if necessary
	for( ;; )
	{
		//Keep iterating as long as another memory region matches
		bool found = 0;

		for( std::vector<UVDMemoryLocation>::iterator iter = m_uvd->m_noncodingAddresses.begin(); iter != m_uvd->m_noncodingAddresses.end(); ++iter )
		{
			UVDMemoryLocation mem = *iter;
			if( mem.intersects(UVDMemoryLocation(m_nextPosition)) )
			{
				found = true;
				//We will keep intersecting until the end of this block
				m_nextPosition = mem.m_max_addr + 1;
				break;
			}
		}
		
		//If we didn't find any more intersections, break
		if( !found )
		{
			break;
		}
	}

	//At the end?
	if( m_nextPosition == data->size() )
	{
		rc = UV_ERR_DONE;
		goto error;
	}

	uv_assert(m_nextPosition <= data->size());
	//Used to get delta for copying the data we just iterated over
	position = m_nextPosition;
	
	opcodeRead = data->read(m_nextPosition);
	printf_debug("Just read @ 0x%.8X: 0x%.2X\n", m_nextPosition, opcodeRead);
	if( opcodeRead < 0 )
	{
		printf_debug("Out of range\n");
		UV_ERR(rc);
		goto error;
	}
	opcode = opcodeRead;
	++m_nextPosition;
	//inst_shared = opcode_structs[opcode];
	//inst_shared
	uv_assert(m_uvd->m_opcodeTable);
	//element = m_uvd->m_opcodeTable->m_lookupTable[opcode];
	uv_assert_err(m_uvd->m_opcodeTable->getElement(opcode, &element));

	if( element == NULL )
	{
		printf_debug("Undefined instruction: 0x%.2X\n", opcode);
		UV_ERR(rc);
		goto error;
	}
	//XXX: this may change in the future to be less direct
	inst_shared = element;
	printf_debug("Memoric: %s\n", inst_shared->m_memoric.c_str());
	
	/*
	inst = new UVDInstruction();
	if( !inst )
	{
		UV_ERR(rc);
		goto error;
	}
	*/
	inst->m_offset = position;
	inst->m_shared = inst_shared;
	inst->m_uvd = m_uvd;

	/*
	Setup extension structs
	There should be a perfect matching between each of these and the shared structs
	*/
	/* Since operand and shared operand structs are linked list, we can setup the entire structure by passing in the first elements */
	if( UV_FAILED(inst->parseOperands(m_nextPosition, inst->m_shared->m_operands, inst->m_operands)) )
	{
		UV_ERR(rc);
		goto error;
	}
	uv_assert_all(m_nextPosition > position);
	printf_debug("m_nextPosition, initial: %d, final: %d\n", position, m_nextPosition);

	inst->m_inst_size = m_nextPosition - position;
	/* For now these should match */
	if( inst->m_inst_size != inst->m_shared->m_total_length )
	{
		printf_debug("Instruction size: %d, shared size: %d\n", inst->m_inst_size, inst->m_shared->m_total_length);
		UV_ERR(rc);
		goto error;
	}
	
	/* We now know the actual size, read the data we just iterated over */
	if( data->read(inst->m_offset, inst->m_inst, inst->m_inst_size) != (int)inst->m_inst_size )
	{
		UV_ERR(rc);
		goto error;
	}
	
	/*
	{
		std::string sPrint;
		
		for( unsigned int i = 0; i < inst->m_inst_size; ++i )
		{
			unsigned int c_temp = inst->m_inst[i];
			printf_debug("inst[%d]: 0x%.2X\n", i, c_temp);
		}
		
		if( UV_FAILED(inst->print_disasm(sPrint)) )
		{
			printf_debug("Could not print\n");
			goto error;
		}
		printf_debug("early print: %s\n", sPrint.c_str());
	}
	*/
	
	m_positionIndex = 0;
	
	rc = UV_ERR_OK;
	
error:
	printf_debug("m_nextPosition, initial: %d, final: %d\n", position, m_nextPosition);

	return UV_DEBUG(rc);
}	

/*
uv_err_t UVDIterator::parseOperands(UVDInstruction *instruction)
{
	uv_err_t rc = UV_ERR_GENERAL;
	uv_assert(instruction);
	uv_assert(instruction->m_shared);
	rc = UV_ERR(UVDOperand::parseOperands(m_uvd, m_nextPosition, instruction->m_shared->m_operands, instruction->m_operands));
error:
	return UV_ERR(rc);
}
*/

void UVDIterator::debugPrint() const
{
	printf_debug("post next, offset: 0x%.8X, index: %d, buffer size: %d\n", m_nextPosition, m_positionIndex, m_indexBuffer.size()); 
}

bool UVDIterator::operator==(const UVDIterator &other) const
{
	UV_ENTER();

	printf_debug("UVDIterator::operator==:\n");
	debugPrint();
	other.debugPrint();

	//Should comapre m_uvd as well?
	return m_nextPosition == other.m_nextPosition 
			&& m_positionIndex == other.m_positionIndex
			//This check is needed for proper ending
			//.end will not have a buffer, but post last address read will (or we are at .end anyway)
			&& m_indexBuffer.size() == other.m_indexBuffer.size();
}

bool UVDIterator::operator!=(const UVDIterator &other) const
{
	return !operator==(other);
}

std::string UVDIterator::operator*()
{
	UV_ENTER();
	
	//New object not yet initialized?
	printf_debug("Index buffer size: %d\n", m_indexBuffer.size());
	if( m_indexBuffer.empty() )
	{
		printf_debug("Priming iterator\n");
		if( UV_FAILED(nextCore()) )
		{
			printf_debug("Failed to prime iterator!\n");
			exit(0);
		}
	}

	printf_debug("position index: %d\n", m_positionIndex);
	if( m_positionIndex >= m_indexBuffer.size() )
	{
		printf_debug("Index out of bounds\n");
		exit(0);
	}
	return m_indexBuffer[m_positionIndex];
}
