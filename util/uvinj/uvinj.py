#!/usr/bin/python
# uvinj: library (DLL) injection interface
# Generates C++ interface suitble for DLL injection
# Copyright 2009 John McMaster <JohnDMcMaster@gmail.com>

# TODO:
# doesn't like function pointer params
# function input printf check commas
# C++ style names (Ex: AVUpdate@8)
# sometimes decompile mistakenly gives this param, replace with athis or something
# What to do when DLLMain is an ordinal

# for completly unknown func
# have global var to save old ret address
# save old ret address on global var
# put would be generated ret adddress in place, call function without saving ret address
# restore ret addresss
# 
# limitation: would require some work with stack to get reentrant funcs to work properly

import os
import sys

# DLL=myutils

def usage():
	print "injection_interface.py <file>"

# extern int g_DebugFlags;
# int __stdcall GetAlerter(int a1);
configFile = "injection_sample.inj"
if len(sys.argv) < 2:
	print "ERROR: you must specify a file name"
	usage()
	sys.exit(1)

configFile = sys.argv[1]


# header place at top of each file
copyright = """\
/*
 * Generated by uvinj.py
 * uvinj.py copyright 2009 John McMaster <JohnDMcMaster@gmail.com>
 */


"""

# Default to pad by space
padSpaces = True
# How many spaces per tab, if using tab based padding
tabSpacing = 4

# Without.dll
dllName = "mydll"

# Variables that have an ordinal
variables = list()
# Functions that have an ordian
functions = list()

KEY_VARIABLE_NAME = "name"
KEY_VARIABLE_ORDINAL = "ordinal"
KEY_VARIABLE_TYPE_RAW = "typeRaw"
KEY_VARIABLE_TYPE_KEYED = "typeKeyed"

KEY_FUNCTION_NAME = "name"
KEY_FUNCTION_ARGS_KEYED = "argumentsKeyed"
KEY_FUNCTION_ARGS_RAW = "argumentsRaw"
# Comma seperated list of function arguments
KEY_FUNCTION_ARGS_NAMES = "argumentsNames"

# Aggregate information in the return vicinity
# needs better name
KEY_FUNCTION_RETURN_KEYED = "returnKeyed"
# KEY_FUNCTION_RETURN_RAW = "returnRaw"
# Misc declaration such as __stdcall and such
KEY_FUNCTION_DECL_RAW = "declarationRaw"
# The return type
KEY_FUNCTION_RETURN_TYPE_RAW = "returnTypeRaw"

KEY_FUNCTION_ORDINAL = "ordinal"
# name of the typedef for this function
KEY_FUNCTION_TYPEDEF = "type"
# Global pointer variable
KEY_FUNCTION_VARIABLE = "variable"

# map members of KEY_FUNCTION_ARGS
# full type of variable, eg wchar_t *
KEY_ARG_TYPE_RAW = "type"
# What is needed to print it basically, int, char, char *, wchar_t *
#KEY_ARG_PRINT_TYPE = "class"
KEY_ARG_NAME = "name"

# KEY_ARG_PRINT_TYPE values 
# No return value
PRINT_TYPE_VOID = "void"
# Signed integer
PRINT_TYPE_INT = "int"
# Unsigned integer
PRINT_TYPE_UINT = "unsigned int"
PRINT_TYPE_ADDRESS = "address"
# For an int sized hex print
PRINT_TYPE_HEX = "hex"
PRINT_TYPE_DOUBLE = "double"
PRINT_TYPE_CHAR = "char"
# Character pointer (C string)
PRINT_TYPE_PCHAR = "pchar"
# wchar_t pointer (wide C like string)
PRINT_TYPE_PWCHAR = "pwchar"

CALLING_CONVENTIONS = ("__cdecl", "__stdcall", "__thiscall", "__naked", "__fastcall")
DEFAULT_CALLING_CONVENTION = "__stdcall"

# High level type of the data we parsed
PRINT_TYPE = "type"
# printf format string
PRINT_FORMAT = "format"
# Cast that may be needed to compile the format argument properly (eg: to print char as hex may require complicated cast)
PRINT_CAST = "cast"

# So we can swap out for desired types if needed
SIZED_TYPES_MS = {"u8":"__uint8", "i8":"__int8", "u16":"__uint16", "i16":"__int16", "u32":"__uint32", "i32":"__int32"}
SIZED_TYPES_ISO = {"u8":"uint8_t", "i8":"int8_t", "u16":"uint16_t", "i16":"int16_t", "u32":"uint32_t", "i32":"int32_t"}
SIZED_TYPES = SIZED_TYPES_ISO

# SIZED_TYPES["u32"]
DEFAULT_RETURN_TYPE = "void"

def emitWarning(warning):
	print "WARNING: " + warning

def emitError(error):
	print "ERROR: " + error
	raise NameError('ERROR')
	sys.exit(1)

def getPrintInformation( declaredType ):
	'''Given a type as used to declare variable'''

	return getFormatString(getPrintType(declaredType))

def getPrintType( declaredType ):
	'''Get a formatting class based on a string representation of a type given'''

	if declaredType == "":
		raise NameError('Empty type')
	elif declaredType.find("**") >= 0 :
		printType = PRINT_TYPE_ADDRESS
	elif declaredType.find("int") >= 0 or declaredType.find("DWORD") >= 0 or declaredType.find("HANDLE") >= 0 or declaredType.find("HKEY") >= 0:
		printType = PRINT_TYPE_INT
	elif declaredType.find("double") >= 0 :
		printType = PRINT_TYPE_DOUBLE
	elif declaredType.find("char *") >= 0 :
		printType = PRINT_TYPE_PCHAR
	elif declaredType.find("wchar_t *") >= 0 or declaredType.find("LPCWSTR") >= 0:
		printType = PRINT_TYPE_PWCHAR
	elif declaredType.find("char") >= 0 :
		printType = PRINT_TYPE_CHAR
	elif declaredType.find("*") >= 0 or declaredType.find("LPVOID") >= 0:
		printType = PRINT_TYPE_ADDRESS
	elif declaredType.find("void") >= 0 :
		printType = PRINT_TYPE_VOID
	else :
		emitWarning("unknown type, assuming hex print: " + declaredType)
		printType = PRINT_TYPE_HEX

	#print "assigned print type: " + printType + " to " + declaredType

	return printType

def getFormatString( printType ):
	'''Given a formatting class, generate actual format strings'''

	formatString = ""
	argumentCastString = ""


	if printType == PRINT_TYPE_VOID:
		emitError("cannot have void in arguments")
	elif printType == PRINT_TYPE_INT:
		formatString = "0x%.8X"
	elif printType == PRINT_TYPE_UINT:
		formatString = "0x%.8X"
	elif printType == PRINT_TYPE_ADDRESS:
		formatString = "0x%.8X"
		argumentCastString = "(int)"
	elif printType == PRINT_TYPE_DOUBLE:
		formatString = "%lf"
	elif printType == PRINT_TYPE_CHAR:
		formatString = "%c"
	elif printType == PRINT_TYPE_PCHAR:
		formatString = "%s"
	elif printType == PRINT_TYPE_PWCHAR:
		formatString = "%ls"
	elif printType == PRINT_TYPE_HEX:
		formatString = "0x%.8X"
		argumentCastString = "(int)"
	else:
		formatString = "0x%.8X"
		argumentCastString = "(int)"

	ret = dict()
	ret[PRINT_TYPE] = printType
	ret[PRINT_FORMAT] = formatString
	ret[PRINT_CAST] = argumentCastString
	return ret


print "Reading config file"

# Map module IDs to module names
infile = open(configFile,"r")
curOrdinal = 0
for line in infile:

	# Remove trailing \n
	line = line[:-1]

	# Ignore blank lines
	if line == "":
		continue

	print ""
	print "Processing line: " + line

	# look for config entries
	if line.find('=') > 0:
		parts = line.split('=')
		key = parts[0]
		value = parts[1]

		if key == "DLL":
			dllName = value
		else:
			print "Unrecognized config entry: " + line
			raise NameError('ERROR')
			#sys.exit(1)
	# Assume ordinal line then
	else:
		curOrdinal = curOrdinal + 1

		if line.find("extern") >= 0:
			variable = dict()
			# extern int g_DebugFlags
			parts = line.split(" ")

			print "A variable, mostly ignoring for now"

			variable[KEY_VARIABLE_ORDINAL] = str(curOrdinal)

			variableName = parts[-1]
			variable[KEY_VARIABLE_NAME] = variableName

			# Skip extern and last
			variableTypeRaw = parts[1:-1]
			variable[KEY_VARIABLE_TYPE_RAW] = " ".join(variableTypeRaw)

			variables.append(variable)
		else:
			function = dict()

			function[KEY_FUNCTION_ORDINAL] = str(curOrdinal)

			# Unknown function?
			if line.find("(") < 0:
				# Emulate a default declaration so it can be parsed
				functionName = line
				line = DEFAULT_RETURN_TYPE + " "
				if len(DEFAULT_CALLING_CONVENTION) > 0:
					line += DEFAULT_CALLING_CONVENTION + " "
				line += functionName + "();"
		
			# __int16 __stdcall GetDatAndEngineInfo(int a1);

			# Return type, declaration parse
			# __int16 __stdcall GetDatAndEngineInfo
			decorationPart = line[0:line.find('(')]
			decorationParts = decorationPart.split(" ")
			# last if function name
			functionName = decorationParts[-1]

			# We may have a trailing pointer on the function, fixup if needed
			pointerRet = ""
			while functionName[0] == "*":
				pointerRet += "*"
				functionName = functionName[1:]


			# ignore function name from return type
			retParts = decorationParts[0:-1]

			typePart = ""
			declPart = ""
			index = 0
			for retPart in retParts:

				# Fixup for pointers
				if retPart[0] == "*":
					pointerRet += "*"
					retPart = retPart[1:]
					retParts[index] = retPart

				if retPart in CALLING_CONVENTIONS:
					if len(declPart) > 0:
						declPart += " "
					declPart += retPart
				else:
					if len(typePart) > 0:
						typePart += " "
					typePart += retPart

				index = index + 1

			# Blank or with a leading space if needed
			pointerRetString = ""
			if pointerRet != "":
				pointerRetString = " " + pointerRet

			retPartAll = " ".join(retParts) + pointerRetString
			typePartAll =  typePart + pointerRetString

			#print "Pre name (ret) parts: : " + retPartAll
			#function[KEY_FUNCTION_RETURN_RAW] = retPartAll
			print "Type only: " + typePartAll
			print "Decl only: " + declPart


			# Arguments parsing
			# wchar_t *Str, int a2, int a3
			argsRaw = line[line.find('(') + 1:line.find(')')]
			print "arguments part: " + argsRaw
			args = list()
			argsNames = ""
			if len(argsRaw) == 0:
				print "No args"
			else:
				argsRawVector = argsRaw.split(", ")
				for argRaw in argsRawVector:
					arg = dict()
					print "Processing arg " + argRaw
					# wchar_t *Str
					argParts = argRaw.split(" ")

					argName = argParts[-1]
					argType = " ".join(argParts[0:-1])

					pointerArg = ""
					while argName[0] == "*":
						pointerArg += "*"
						argName = argName[1:]
					if len(pointerArg) > 0:
						argType += " " + pointerArg

					print "Arg raw: " + argRaw
					print "Arg type raw: " + argType
					print "Arg name: " + argName
					arg[KEY_ARG_TYPE_RAW] = argType
					arg[KEY_ARG_NAME] = argName

					# Build up a typeless list
					if len(argsNames) > 0:
						argsNames += ", "
					argsNames += argName

					args.append(arg)

			function[KEY_FUNCTION_NAME] = functionName
			function[KEY_FUNCTION_ARGS_RAW] = argsRaw
			function[KEY_FUNCTION_RETURN_TYPE_RAW] = typePartAll
			function[KEY_FUNCTION_DECL_RAW] = declPart
			# originally was just _, but had issues with conflicting with other progs that used same convention
			functionVariable = "_uvinj_" + functionName
			function[KEY_FUNCTION_VARIABLE] = functionVariable
			functionType = functionName + "_t"
			function[KEY_FUNCTION_TYPEDEF] = functionType
			function[KEY_FUNCTION_ARGS_NAMES] = argsNames
			function[KEY_FUNCTION_ARGS_KEYED] = args

			functions.append(function)

infile.close()

print ""
print "***"
print "Parse complete"
print "***"
print ""



# Calculate derrived data from configurable options

# Should have same name as our original DLL
injectionDllBase = dllName
injectionDllBasename = injectionDllBase + ".dll"
injectionDllDir = ""
injectionDllNameFull = injectionDllDir + injectionDllBasename

realDllBase = dllName + "_real"
realDllBasename = realDllBase + ".dll"
realDllDir = ""
realDllNameFull = realDllDir + realDllBasename

# A file that is not generated, included in header (if define is used) and allows fixup
customHeaderFileDefine = "DLLINJECTION_CUSTOM_HEADER"
customHeaderFileName = dllName + "_custom.h"

headerFileName = dllName + ".h"
headerFileBaselineName = dllName + ".h.gen"
sourceFileName = dllName + ".cpp"
sourceFileBaselineName = dllName + ".cpp.gen"
defFileName = dllName + ".def"


# Derrived strings
# Like MYDLL_API
exportDefine = dllName.upper() + "_API"
# like MYDLL_EXPORTS
exportCheckDefine = dllName.upper() + "_EXPORTS"

callPrintPrefix = "**" + dllName + "::"
retPrintPrefix = "*" + dllName + "::"


# def file
# LIBRARY   mydll.dll
# EXPORTS
#	?g_DebugFlags@@3HA       @1
#	MyFunction               @2

toWrite = ""
toWrite += "LIBRARY " + injectionDllBase + ".dll\n"
toWrite += "EXPORTS\n"
for variable in variables:
	variableName = variable[KEY_VARIABLE_NAME]
	variableOrdinal = variable[KEY_VARIABLE_ORDINAL]

	toWrite += "\t" + variableName + "\t\t@" + variableOrdinal + "\n"

for function in functions:
	functionName = function[KEY_FUNCTION_NAME]
	functionOrdinal = function[KEY_FUNCTION_ORDINAL]

	toWrite += "\t" + functionName + "\t\t@" + functionOrdinal + "\n"

outputFileName = defFileName
print "Writting to " + outputFileName
outputFile = open(outputFileName, "w")
outputFile.writelines(toWrite)
outputFile.close()
print "Wrote file!"
print ""



# Header file

toWrite = ""

toWrite += copyright

toWrite += "#pragma once\n"

# Import/export block
toWrite += "#ifdef " + exportCheckDefine + "\n"
toWrite += "#define " + exportDefine + " __declspec(dllexport)\n"
toWrite += "#else\n"
toWrite += "#define " + exportDefine + " __declspec(dllimport)\n"
toWrite += "#endif\n"
toWrite += "\n"
toWrite += "\n"

# More than likely they'll need this and it certainly won't hurt
toWrite += "#include <windows.h>\n"
toWrite += "\n"
toWrite += "#ifdef " + customHeaderFileDefine + "\n"
toWrite += "#include \"" + customHeaderFileName + "\"\n"
toWrite += "#endif // " + customHeaderFileDefine + "\n"
toWrite += "\n"

for variable in variables:
	variableName = variable[KEY_VARIABLE_NAME]
	variableTypeRaw = variable[KEY_VARIABLE_TYPE_RAW]
	variableOrdinal = variable[KEY_VARIABLE_ORDINAL]

	toWrite += "//Ordinal  " + variableOrdinal + "\n"
	toWrite += "extern " + variableTypeRaw + " " + variableName + ";\n"
	toWrite += "\n"

# Header prototypes 
	# //Ordinal 2
	# typedef MYDLL_API int __stdcall (*GetAlerter_t)(int a1);
	# MYDLL_API int __stdcall GetAlerter(int a1);
for function in functions:
	functionName = function[KEY_FUNCTION_NAME]
	functionArgsRaw = function[KEY_FUNCTION_ARGS_RAW]
	functionType = function[KEY_FUNCTION_TYPEDEF]
	functionReturnType = function[KEY_FUNCTION_RETURN_TYPE_RAW]

	toWrite += "//Ordinal " + function[KEY_FUNCTION_ORDINAL] + "\n"

	declString = function[KEY_FUNCTION_DECL_RAW]
	if declString != "":
		declString += " "
	
	# typedef void (__stdcall *TestStdcall_t)();
	typedef = "typedef " + functionReturnType + "(" + declString + "*" + functionType + ")(" + functionArgsRaw + ");\n"
	toWrite += typedef
	
	# void __stdcall TestStdcall();
	prototype = ""
	if len(exportDefine) > 0:
		prototype += exportDefine.strip() + " "
	prototype += functionReturnType + " "
	if len(declString) > 0:
		prototype += declString.strip() + " "
	prototype += functionName.strip() + "(" + functionArgsRaw + ");\n"
	toWrite += prototype
	
	toWrite += "\n"

toWrite += "\n"


outputFileName = headerFileName
print "Writting to " + outputFileName
outputFile = open(outputFileName, "w")
outputFile.writelines(toWrite)
outputFile.close()
print "Wrote file!"
print ""

outputFileName = headerFileBaselineName
print "Writting to " + outputFileName
outputFile = open(outputFileName, "w")
outputFile.writelines(toWrite)
outputFile.close()
print "Wrote file!"
print ""


# Source file

toWrite = ""
globalLibraryHandle = "g_hLibrary"

if copyright != "":
	toWrite += copyright
	toWrite += "\n"

# I hate these but am too lazy to remove them from projects for now
#toWrite += "#include \"stdafx.h\"\n"
toWrite += "#include \"" + injectionDllBase + ".h\"\n"
toWrite += "#include <windows.h>\n"
toWrite += "#include <stdio.h>\n"
toWrite += "#include <stdlib.h>\n"

toWrite += """
/*
Calling LoadLibrary() in DllInit() is not reccomended, but may work
I had trouble with it and had to stop using it
If this is not defined, Init() will be attempted upon arbitrary function loads
If the library exports global variables and they are manipulated before a 
function is called, you may get unpredictable behavior because those variables
may not have the expected initial value
In this case, you will have to find the initial value of the variables and set them in this DllMain

See http://msdn.microsoft.com/en-us/library/ms682583(VS.85).aspx
*/
//#define USING_DLLMAIN_INIT
""";


toWrite += """
/*
Should we do a LoadLibrary for each DLLMain PROCESS_ATTACH we recieve?
Unless the library is doing any hacks, this isn't necessary as it will get proper signals from our natrual termination
*/
//#define USING_MULTIPLE_INIT
""";


toWrite += "\n"
toWrite += "\n"
toWrite += "HINSTANCE " + globalLibraryHandle + " = NULL;\n"
toWrite += "//Global variables\n"
toWrite += "extern \"C++\"\n"
toWrite += "{\n"
for variable in variables:
	variableName = variable[KEY_VARIABLE_NAME]
	variableTypeRaw = variable[KEY_VARIABLE_TYPE_RAW]
	variableOrdinal = variable[KEY_VARIABLE_ORDINAL]

	toWrite += "\t//Ordinal " + variableOrdinal + "\n"
	toWrite += "\t" + variableTypeRaw + " " + variableName + ";\n"
	toWrite += "\n"

toWrite += "}\n"
toWrite += "//Pointers to real calls\n"
for function in functions:
	functionName = function[KEY_FUNCTION_NAME]
	functionOrdinal = function[KEY_FUNCTION_ORDINAL]
	functionType = function[KEY_FUNCTION_TYPEDEF]
	functionVariable = function[KEY_FUNCTION_VARIABLE]

	toWrite += "//Ordinal " + functionOrdinal + "\n"
	toWrite += functionType + " " + functionVariable + " = NULL;\n"
toWrite += "\n"
toWrite += "\n"

def printOrdinalPointerAddresses():
	toPrint = ""

	toPrint += "void PrintOrdinalPointerAddresses()\n"
	toPrint += "{\n"

	for variable in variables:
		variableName = variable[KEY_VARIABLE_NAME]
		variableOrdinal = variable[KEY_VARIABLE_ORDINAL]

		toPrint += "\tprintf(\"" + variableName + "(" + variableOrdinal + ", 0x%.8X): 0x%.8X\\n\", &" + variableName + ", " + variableName + ");\n"

	for function in functions:
		functionVariable = function[KEY_FUNCTION_VARIABLE]
		functionOrdinal = function[KEY_FUNCTION_ORDINAL]

		toPrint += "\tprintf(\"" + functionVariable + "(" + functionOrdinal + ", 0x%.8X): 0x%.8X\\n\", &" + functionVariable + ", " + functionVariable + ");\n"

	toPrint += "}\n"

	return toPrint

toWrite += printOrdinalPointerAddresses()

toWrite += """
BOOL Init()
{
	BOOL rc = FALSE;
	if( """ + globalLibraryHandle + """ != NULL )
	{
#ifdef VERBOSE
		printf("Already loaded\\n");
#endif //VERBOSE
		return TRUE;
	}
	//Note: will call target library's DLLMain
"""
toWrite += "\tconst char *szLibrary = \"" + realDllNameFull + "\";\n"
toWrite += """\
	printf("Loading library %s\\n", szLibrary);
	""" + globalLibraryHandle + """ = LoadLibrary(szLibrary);
	if( """ + globalLibraryHandle + """ == NULL )
	{
		printf("Failed to load library %s\\n", szLibrary);
		goto error;
	}

""";

for function in functions:
	functionName = function[KEY_FUNCTION_NAME]
	functionOrdinal = function[KEY_FUNCTION_ORDINAL]
	functionType = function[KEY_FUNCTION_TYPEDEF]
	functionVariable = function[KEY_FUNCTION_VARIABLE]

	toWrite += "\t" + functionVariable + " = (" + functionType + ")GetProcAddress(" + globalLibraryHandle + ", MAKEINTRESOURCEA(" + functionOrdinal + "));\n"
	toWrite += "\tif( !" + functionVariable + ")\n"
	toWrite += "\t{\n"
	toWrite += "\t\tprintf(\"Failed to load ordinal: " + functionOrdinal + " (" + functionName + ")\\n\");\n"
	toWrite += "\t\tgoto error;\n"
	toWrite += "\t}\n"
	toWrite += "\n"

toWrite += """
#ifdef VERBOSE
	printf("All ordinals loaded!\\n");
	PrintOrdinalPointerAddresses();
#endif //VERBOSE
	rc = TRUE;
error:
#ifndef USING_DLLMAIN_INIT
	if( !rc )
	{
		exit(1);
	}
#endif // USING_DLLMAIN_INIT
	return rc;
}

void Deinit()
{
	if( """ + globalLibraryHandle + """ )
	{
		FreeLibrary(""" + globalLibraryHandle + """);
		""" + globalLibraryHandle + """ = NULL;
	}
}

BOOL APIENTRY DllMain( HANDLE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
"""

toWrite += "#ifdef VERBOSE\n"
toWrite += "\tprintf(\"" + dllName + "::DDLMain()\\n\");\n"
toWrite += "#endif //VERBOSE\n"
toWrite += """\
	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
#ifdef VERBOSE
			printf(\"DLL_PROCESS_ATTACH\\n\");
#endif //VERBOSE
#ifdef USING_DLLMAIN_INIT
			if( !Init() )
			{
				printf(\"Init failed!\\n\");
				return FALSE;
			}
#endif //USING_DLLMAIN_INIT
			break;
		case DLL_THREAD_ATTACH:
#ifdef VERBOSE
			printf(\"DLL_THREAD_ATTACH\\n\");
#endif //VERBOSE
			break;
		case DLL_THREAD_DETACH:
#ifdef VERBOSE
			printf(\"DLL_THREAD_DETACH\\n\");
#endif //VERBOSE
			break;
		case DLL_PROCESS_DETACH:
#ifdef VERBOSE
			printf(\"DLL_PROCESS_DETACH\\n\");
#endif //VERBOSE
			Deinit();
			break;
		default:
#ifdef VERBOSE
			printf(\"unknown\\n\");
#endif //VERBOSE
			break;
	}
	return TRUE;
}

"""

def getFunctionDefinition(function):
	functionName = function[KEY_FUNCTION_NAME]
	functionOrdinal = function[KEY_FUNCTION_ORDINAL]
	functionType = function[KEY_FUNCTION_TYPEDEF]
	functionVariable = function[KEY_FUNCTION_VARIABLE]
	#functionReturnRaw = function[KEY_FUNCTION_RETURN_RAW]
	functionReturnTypeRaw = function[KEY_FUNCTION_RETURN_TYPE_RAW]
	functionDeclRaw = function[KEY_FUNCTION_DECL_RAW]
	functionArgsKeyed = function[KEY_FUNCTION_ARGS_KEYED]
	functionArgsRaw = function[KEY_FUNCTION_ARGS_RAW]
	functionArgsNames = function[KEY_FUNCTION_ARGS_NAMES]

	print "Generating " + functionName + "..."

	toWrite = ""

	printType = getPrintType(functionReturnTypeRaw)
	isVoid = printType == PRINT_TYPE_VOID

	toWrite += "//Ordinal " + functionOrdinal + "\n"
	# CAAVSCAN_API bool __cdecl function_1(CAAVSCAN_HANDLE *handle)
	toWrite += exportDefine + " " + functionReturnTypeRaw + " " + functionDeclRaw + " " + functionName + "(" + functionArgsRaw + ")\n" 
	toWrite += "{\n"

	if not isVoid:
		toWrite += "\t" + functionReturnTypeRaw + " ret;\n"

	# printf("caavscan_1(CAAVSCAN_HANDLE handle = 0x%.8X)\n",
	#		(int)handle);
	# The entire content of the printf string inside the double quotes
	printfFormat = ""
	# The entire content of the arguments after the format string, empty if they do not exist
	printfArgs = ""

	printfFormat += callPrintPrefix + functionName + "("
	isFirst = True
	for argument in functionArgsKeyed:

		argumentType = argument[KEY_ARG_TYPE_RAW]
		argumentName = argument[KEY_ARG_NAME]

		printInformation = getPrintInformation(argumentType)

		formatString = printInformation[PRINT_FORMAT]
		argumentCastString = printInformation[PRINT_CAST]

		# Slap it together
		printfFormat += argumentType + " " + argumentName + " = " + formatString

		# Comma only if more args to come
		if not isFirst:
			printfFormat += ", "
			printfArgs += ", "

		printfArgs += argumentCastString + argumentName
		isFirst = False

	printfFormat += ")\\n"

	toWrite += "\tprintf(\"" + printfFormat + "\""
	# Put args on newline if present
	if len(printfArgs) > 0:
		toWrite += ",\n\t\t\t" + printfArgs
	toWrite += ");\n" 

	# In case it crashes, likely because of our fault not passing args right or something
	toWrite += "\tfflush(stdout);\n"


	# Do this after printing the function
	toWrite += """
#ifndef USING_DLLMAIN_INIT
	if( !Init() )
	{
		printf("Failed init from """ + functionName + """()\\n");
		exit(1);
	}
#endif
"""


	# The function call
	retCallString = ""
	if not isVoid:
		retCallString = "ret = "
	toWrite += "\t" + retCallString + functionVariable + "(" + functionArgsNames + ");\n"

	# return value, if applicable
	if not isVoid:
		returnPrintInformation = getPrintInformation(functionReturnTypeRaw)
		retFormat = returnPrintInformation[PRINT_FORMAT]
		retCast = returnPrintInformation[PRINT_CAST]

		toWrite += "\tprintf(\"" + retPrintPrefix + functionName + ": " + functionReturnTypeRaw + " ret = " + retFormat + "\\n\", ret);\n"
		toWrite += "\tfflush(stdout);\n"
		toWrite += "\treturn ret;\n"
	toWrite += "}\n"
	toWrite += "\n"

	return toWrite

for function in functions:
	toWrite += getFunctionDefinition(function)

outputFileName = sourceFileName
print "Writting to " + outputFileName
outputFile = open(outputFileName, "w")
outputFile.writelines(toWrite)
outputFile.close()
print "Wrote file!"
print ""

outputFileName = sourceFileBaselineName
print "Writting to " + outputFileName
outputFile = open(outputFileName, "w")
outputFile.writelines(toWrite)
outputFile.close()
print "Wrote file!"
print ""
